#!/bin/bash
# csb - Claude SandBox
# Lima-powered sandboxed environment for Claude Code development

set -e

VERSION="0.1.0"
CSB_DIR="${HOME}/.csb"
CSB_FILE=".csb"
VERBOSE="${CSB_VERBOSE:-false}"

# Find csb share directory (template.yaml, provision scripts, etc.)
# Search order: $CSB_SHARE_DIR, /usr/local/share/csb, script directory
get_share_dir() {
    # 1. Environment override
    if [[ -n "${CSB_SHARE_DIR:-}" && -d "${CSB_SHARE_DIR}" ]]; then
        echo "${CSB_SHARE_DIR}"
        return
    fi
    # 2. System install location
    if [[ -d "/usr/local/share/csb" ]]; then
        echo "/usr/local/share/csb"
        return
    fi
    # 3. Same directory as script (dev/clone install)
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    echo "${script_dir}"
}

CSB_SHARE_DIR_RESOLVED="$(get_share_dir)"
TEMPLATE_FILE="${CSB_DIR}/template.yaml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Print colored message
info() { echo -e "${BLUE}[csb]${NC} $1"; }
success() { echo -e "${GREEN}[csb]${NC} $1"; }
warn() { echo -e "${YELLOW}[csb]${NC} $1"; }
error() { echo -e "${RED}[csb]${NC} $1" >&2; }
dim() { echo -e "${GRAY}     $1${NC}"; }

# Display any CSB_WARN messages from provisioning log
show_provisioning_warnings() {
    local vm_name="$1"
    local warnings
    warnings=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_WARN:' /var/log/cloud-init-output.log 2>/dev/null | sed 's/.*CSB_WARN://' || true)
    if [[ -n "${warnings}" ]]; then
        echo ""
        while IFS= read -r warning_msg; do
            warn "⚠ ${warning_msg}"
        done <<< "${warnings}"
    fi
}

# Spinner animation constants
SPINNER_CHARS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
SPINNER_DELAY=0.1

# Core spinner loop - runs in subshell, renders spinner with optional timing
# Args: statefile (empty for simple mode), message (for simple mode)
_spinner_loop() {
    local statefile="$1"
    local static_msg="$2"
    local i=0
    local stime=$(date +%s)

    while true; do
        local msg elapsed_str=""
        if [[ -n "$statefile" ]]; then
            [[ -f "$statefile" ]] || break
            msg=$(head -1 "$statefile" 2>/dev/null || echo "Starting")
            local elapsed=$(($(date +%s) - stime))
            if [[ $elapsed -lt 60 ]]; then
                elapsed_str=" ${GRAY}[${elapsed}s]${NC}"
            else
                elapsed_str=" ${GRAY}[$((elapsed / 60))m $((elapsed % 60))s]${NC}"
            fi
        else
            msg="$static_msg"
        fi
        echo -en "\r${BLUE}[csb]${NC} ${msg} ${SPINNER_CHARS:$i:1}${elapsed_str}"
        i=$(( (i + 1) % ${#SPINNER_CHARS} ))
        sleep $SPINNER_DELAY
    done
}

# Simple spinner for short operations
spinner_pid=""
start_spinner() {
    local msg="$1"
    if [[ "${VERBOSE}" == "true" ]]; then
        info "$msg"
        return
    fi
    _spinner_loop "" "$msg" &
    spinner_pid=$!
    disown $spinner_pid 2>/dev/null
}

stop_spinner() {
    local success="${1:-true}"
    local msg="${2:-}"

    if [[ -n "$spinner_pid" ]]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null || true
        spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi

    if [[ -n "$msg" ]]; then
        if [[ "$success" == "true" ]]; then
            success "$msg"
        else
            error "$msg"
        fi
    fi
}

# Progress spinner with timing - for long operations with stage updates
progress_spinner_statefile=""
progress_spinner_pid=""

start_progress_spinner() {
    local initial_stage="$1"

    progress_spinner_statefile=$(mktemp)
    echo "${initial_stage}" > "${progress_spinner_statefile}"

    _spinner_loop "$progress_spinner_statefile" "" &
    progress_spinner_pid=$!
    disown $progress_spinner_pid 2>/dev/null
}

update_progress_spinner() {
    local new_stage="$1"
    if [[ -n "${progress_spinner_statefile}" && -f "${progress_spinner_statefile}" ]]; then
        echo "${new_stage}" > "${progress_spinner_statefile}"
    fi
}

stop_progress_spinner() {
    if [[ -n "${progress_spinner_statefile}" ]]; then
        rm -f "${progress_spinner_statefile}"
        progress_spinner_statefile=""
    fi
    if [[ -n "${progress_spinner_pid}" ]]; then
        kill $progress_spinner_pid 2>/dev/null
        wait $progress_spinner_pid 2>/dev/null || true
        progress_spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi
}

# Run command with spinner (suppresses output unless verbose or error)
run_with_spinner() {
    local msg="$1"
    shift
    local success_msg="${1:-}"
    shift

    start_spinner "$msg"

    local output
    local exit_code=0
    if [[ "${VERBOSE}" == "true" ]]; then
        stop_spinner true ""
        info "$msg"
        "$@" || exit_code=$?
    else
        output=$("$@" 2>&1) || exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        stop_spinner true "${success_msg:-$msg... done}"
        return 0
    else
        stop_spinner false "$msg... failed"
        if [[ -n "$output" ]]; then
            echo "$output" >&2
        fi
        # Exit directly to ensure error is visible before set -e kills us
        exit $exit_code
    fi
}

# Cleanup function for all spinners
cleanup_spinners() {
    stop_spinner false "" 2>/dev/null
    stop_progress_spinner 2>/dev/null
}

# Trap EXIT, INT (Ctrl+C), and TERM signals
trap cleanup_spinners EXIT INT TERM

# Escape string for use in sed replacement (handles |, &, \, newlines)
escape_sed_replacement() {
    printf '%s' "$1" | sed -e 's/[&\|]/\\&/g' -e 's/$/\\/' | tr -d '\n' | sed 's/\\$//'
}

# Format seconds as human-readable duration
format_duration() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s"
    else
        local mins=$((seconds / 60))
        local secs=$((seconds % 60))
        echo "${mins}m ${secs}s"
    fi
}

# Check if Lima is installed
check_lima() {
    if ! command -v limactl &> /dev/null; then
        error "Lima is not installed. Please install it first:"
        echo "  brew install lima"
        exit 1
    fi
}

# Generate VM name from directory path
generate_vm_name() {
    local hash=$(echo -n "$(pwd)" | shasum | cut -c1-6)
    echo "csb-${hash}"
}

# Get or create VM name for current directory
get_vm_name() {
    if [[ -f "${CSB_FILE}" ]]; then
        head -n 1 "${CSB_FILE}"
    else
        generate_vm_name
    fi
}

# Save VM config
save_config() {
    local vm_name="$1"
    echo "${vm_name}" > "${CSB_FILE}"
    echo "# csb config - do not edit manually" >> "${CSB_FILE}"
    echo "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${CSB_FILE}"
    echo "workspace=$(pwd)" >> "${CSB_FILE}"
}

# Check if VM exists
vm_exists() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    limactl list --json 2>/dev/null | jq -e "select(.name == \"${vm_name}\")" > /dev/null 2>&1
}

# Require VM to exist, exit with error if not
require_vm() {
    local vm_name="$1"
    local msg="${2:-No VM found for this directory}"
    if ! vm_exists "${vm_name}"; then
        error "${msg}"
        exit 1
    fi
}

# Get VM status
vm_status() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    local status=$(limactl list --json 2>/dev/null | jq -r "select(.name == \"${vm_name}\") | .status" 2>/dev/null)
    echo "${status:-NotFound}"
}

# Create VM from template
create_vm() {
    local vm_name="$1"
    local workspace="$(pwd)"
    local create_start_time=$(date +%s)

    info "Creating VM: ${vm_name}"
    dim "This may take a few minutes on first run..."
    echo ""

    # Ensure CSB directory exists
    mkdir -p "${CSB_DIR}"

    # Always copy latest template (ensures updates are picked up)
    if [[ -f "${CSB_SHARE_DIR_RESOLVED}/template.yaml" ]]; then
        cp "${CSB_SHARE_DIR_RESOLVED}/template.yaml" "${TEMPLATE_FILE}"
    else
        error "Template not found at ${CSB_SHARE_DIR_RESOLVED}/template.yaml"
        error "Please reinstall csb or set CSB_SHARE_DIR."
        exit 1
    fi

    # Create temporary template with workspace substituted
    local tmp_template=$(mktemp)
    local escaped_workspace=$(escape_sed_replacement "${workspace}")
    sed "s|{{WORKSPACE_PATH}}|${escaped_workspace}|g" "${TEMPLATE_FILE}" > "${tmp_template}"

    # Substitute API key if set
    if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        local escaped_key=$(escape_sed_replacement "${ANTHROPIC_API_KEY}")
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}|${escaped_key}|g" "${tmp_template}"
    else
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}||g" "${tmp_template}"
    fi
    rm -f "${tmp_template}.bak"

    # Substitute GitHub token if set (for git HTTPS authentication)
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        local escaped_token=$(escape_sed_replacement "${GITHUB_TOKEN}")
        sed -i.bak "s|{{GITHUB_TOKEN}}|${escaped_token}|g" "${tmp_template}"
    else
        sed -i.bak "s|{{GITHUB_TOKEN}}||g" "${tmp_template}"
    fi
    rm -f "${tmp_template}.bak"

    # Create the VM with progress feedback (--tty=false skips interactive prompts)
    run_with_spinner "Creating VM" "VM created" \
        limactl create --tty=false --name="${vm_name}" "${tmp_template}"
    rm -f "${tmp_template}"

    # Save config
    save_config "${vm_name}"

    local create_elapsed=$(($(date +%s) - create_start_time))
    local create_duration=$(format_duration $create_elapsed)
    echo ""
    success "VM created: ${vm_name} ${GRAY}(${create_duration})${NC}"
}

# Create VM from golden image (no provisioning)
create_vm_from_golden() {
    local vm_name="$1"
    local workspace="$(pwd)"
    local arch=$(uname -m)
    local golden_image="${CSB_DIR}/golden-${arch}.qcow2"

    # Map uname arch to Lima arch
    local lima_arch
    case "${arch}" in
        x86_64)  lima_arch="x86_64" ;;
        arm64)   lima_arch="aarch64" ;;
        aarch64) lima_arch="aarch64" ;;
        *)       error "Unsupported architecture: ${arch}"; exit 1 ;;
    esac

    info "Creating VM from golden image: ${vm_name}"
    echo ""

    # Generate minimal lima.yaml for golden image
    local tmp_template=$(mktemp)
    cat > "${tmp_template}" << YAML
# Lima VM from golden image (pre-provisioned)
images:
  - location: "${golden_image}"
    arch: "${lima_arch}"

cpus: 4
memory: "4GiB"
disk: "30GiB"

mounts:
  - location: "${workspace}"
    mountPoint: "/workspace"
    writable: true

ssh:
  localPort: 0
  forwardAgent: true

containerd:
  system: false
  user: false

env:
  ANTHROPIC_API_KEY: "${ANTHROPIC_API_KEY:-}"
  GITHUB_TOKEN: "${GITHUB_TOKEN:-}"
YAML

    # Create the VM
    run_with_spinner "Creating VM" "VM created" \
        limactl create --tty=false --name="${vm_name}" "${tmp_template}"
    rm -f "${tmp_template}"

    # Save config
    save_config "${vm_name}"
}

# Start VM with progress display
# Polls cloud-init log for CSB_PROGRESS markers
start_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" == "Running" ]]; then
        info "VM already running"
        return 0
    fi

    info "Starting VM: ${vm_name}"
    dim "First start provisions the VM (this takes a few minutes)..."
    echo ""

    if [[ "${VERBOSE}" == "true" ]]; then
        # Verbose mode: show all output
        limactl start --tty=false --progress "${vm_name}"
    else
        # Normal mode: show progress with spinner and timing
        local tmpfile=$(mktemp)
        local exit_code=0
        local last_stage=""
        local current_stage="Booting VM"

        # Timing tracking
        local start_time=$(date +%s)
        local stage_start_time=$start_time

        # Start progress spinner (runs at 0.1s for smooth animation)
        start_progress_spinner "${current_stage}"

        # Start limactl in background (without --progress to avoid noise)
        limactl start --tty=false "${vm_name}" > "${tmpfile}" 2>&1 &
        local lima_pid=$!
        disown $lima_pid 2>/dev/null

        # Monitor progress by polling cloud-init log via SSH (1s interval)
        while kill -0 $lima_pid 2>/dev/null; do
            # Try to get latest progress and check for errors from VM's cloud-init log
            local new_stage=""
            local error_marker=""
            if limactl shell --workdir / "${vm_name}" -- sudo test -f /var/log/cloud-init-output.log 2>/dev/null; then
                new_stage=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_PROGRESS:' /var/log/cloud-init-output.log 2>/dev/null | tail -1 | sed 's/.*CSB_PROGRESS://' || true)
                # Check for explicit error markers from provisioning scripts
                error_marker=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_ERROR:' /var/log/cloud-init-output.log 2>/dev/null | tail -1 | sed 's/.*CSB_ERROR://' || true)
            fi

            # Handle explicit error markers (immediate failure detection)
            if [[ -n "${error_marker}" ]]; then
                stop_progress_spinner
                error "✗ ${current_stage} failed"
                echo ""
                error "Error: ${error_marker}"
                echo "" >&2
                error "Last lines of provisioning output:"
                limactl shell --workdir / "${vm_name}" -- sudo tail -30 /var/log/cloud-init-output.log 2>/dev/null >&2 || true
                kill $lima_pid 2>/dev/null || true
                rm -f "${tmpfile}"
                exit 1
            fi

            if [[ -n "${new_stage}" && "${new_stage}" != "${last_stage}" ]]; then
                # Calculate elapsed time for completed stage
                local now=$(date +%s)
                local stage_elapsed=$((now - stage_start_time))
                local stage_duration=$(format_duration $stage_elapsed)

                # Show completed stage with timing
                stop_progress_spinner
                success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"

                # Start timing new stage
                current_stage="${new_stage}"
                last_stage="${new_stage}"
                stage_start_time=$now

                # Restart spinner with new stage
                start_progress_spinner "${current_stage}"
            fi

            # Check if cloud-init has failed (provisioning script error)
            local cloud_init_status=""
            cloud_init_status=$(limactl shell --workdir / "${vm_name}" -- sudo cat /run/cloud-init/result.json 2>/dev/null || true)
            if [[ -n "${cloud_init_status}" ]]; then
                # result.json exists - check if there were errors
                local has_errors=""
                has_errors=$(echo "${cloud_init_status}" | jq -r '.v1.errors | length' 2>/dev/null || echo "0")
                if [[ "${has_errors}" != "0" ]]; then
                    # Cloud-init completed with errors - extract error details
                    stop_progress_spinner
                    error "✗ ${current_stage} failed"
                    echo ""

                    # Show cloud-init errors
                    local error_msgs=""
                    error_msgs=$(echo "${cloud_init_status}" | jq -r '.v1.errors[]' 2>/dev/null || true)
                    if [[ -n "${error_msgs}" ]]; then
                        error "Cloud-init errors:"
                        echo "${error_msgs}" >&2
                    fi

                    # Show last part of cloud-init log for context
                    echo "" >&2
                    error "Last lines of provisioning output:"
                    limactl shell --workdir / "${vm_name}" -- sudo tail -30 /var/log/cloud-init-output.log 2>/dev/null >&2 || true

                    # Kill the lima process and cleanup
                    kill $lima_pid 2>/dev/null || true
                    rm -f "${tmpfile}"
                    exit 1
                fi
            fi

            sleep 1
        done

        # Stop spinner and get exit code
        stop_progress_spinner
        wait $lima_pid || exit_code=$?

        # Calculate final timing
        local end_time=$(date +%s)
        local final_stage_elapsed=$((end_time - stage_start_time))
        local total_elapsed=$((end_time - start_time))
        local stage_duration=$(format_duration $final_stage_elapsed)
        local total_duration=$(format_duration $total_elapsed)

        if [[ $exit_code -eq 0 ]]; then
            success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"
            echo ""
            success "VM started ${GRAY}(total: ${total_duration})${NC}"

            show_provisioning_warnings "${vm_name}"
        else
            # limactl exited with error - but check if VM is actually running
            # (Lima 2.0 has a bug where it times out waiting for "running" event
            # even when the VM is running and provisioned)
            local actual_status=$(vm_status "${vm_name}")
            if [[ "${actual_status}" == "Running" ]]; then
                # VM is running despite limactl error - check if cloud-init finished
                local cloud_init_done=""
                cloud_init_done=$(limactl shell --workdir / "${vm_name}" -- sudo cat /run/cloud-init/result.json 2>/dev/null || true)
                if [[ -n "${cloud_init_done}" ]]; then
                    # Cloud-init finished - treat as success
                    warn "limactl reported timeout, but VM is running"
                    success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"
                    echo ""
                    success "VM started ${GRAY}(total: ${total_duration})${NC}"

                    show_provisioning_warnings "${vm_name}"
                    rm -f "${tmpfile}"
                    return 0
                fi
            fi

            # VM is not running or cloud-init didn't finish - actual failure
            error "Failed to start VM after ${total_duration}"
            echo ""
            # Show output for debugging
            cat "${tmpfile}" >&2
            rm -f "${tmpfile}"
            exit $exit_code
        fi

        rm -f "${tmpfile}"
    fi
}

# Stop VM
stop_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" != "Running" ]]; then
        info "VM is not running"
        return 0
    fi

    run_with_spinner "Stopping VM" "VM stopped" \
        limactl stop "${vm_name}"
}

# Get next tmux session number
get_next_session() {
    local vm_name="$1"
    local sessions=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)

    if [[ -z "${sessions}" ]]; then
        echo "claude-1"
    else
        local num=$(echo "${sessions}" | sed 's/claude-//')
        echo "claude-$((num + 1))"
    fi
}

# List tmux sessions
list_sessions() {
    local vm_name="$1"
    limactl shell --workdir / "${vm_name}" -- tmux list-sessions 2>/dev/null || echo "No sessions"
}

# Get git remote URL from current directory
get_git_remote() {
    git remote get-url origin 2>/dev/null || echo ""
}

# Get agent slot number for consistent port assignment
# Extracts trailing number from name, or derives from UID
get_agent_slot() {
    local vm_name="$1"
    local agent_name="$2"

    # Try to extract trailing number from agent name (e.g., "agent1" -> 1)
    local trailing_num=$(echo "${agent_name}" | grep -oE '[0-9]+$' || true)
    if [[ -n "${trailing_num}" ]]; then
        echo "${trailing_num}"
        return
    fi

    # Fall back to UID-based slot (UID - 1000)
    local uid=$(limactl shell --workdir / "${vm_name}" -- id -u "${agent_name}" 2>/dev/null || echo "1001")
    echo "$((uid - 1000))"
}

# Start a named agent with isolated user
# Creates Linux user, clones repo, runs claude as that user
start_agent() {
    local vm_name="$1"
    local agent_name="$2"
    local git_remote="$3"

    # Validate agent name (alphanumeric and hyphens only)
    if [[ ! "${agent_name}" =~ ^[a-zA-Z][a-zA-Z0-9-]*$ ]]; then
        error "Invalid agent name: ${agent_name}"
        echo "Agent names must start with a letter and contain only letters, numbers, and hyphens."
        exit 1
    fi

    info "Setting up agent: ${agent_name}"

    # Create user if not exists (suppress error if exists)
    limactl shell --workdir / "${vm_name}" -- sudo useradd -m -s /bin/bash "${agent_name}" 2>/dev/null || true

    # Secure home directory (only this user can access)
    limactl shell --workdir / "${vm_name}" -- sudo chmod 700 "/home/${agent_name}"

    # Get agent slot for consistent port mapping
    local agent_slot=$(get_agent_slot "${vm_name}" "${agent_name}")
    local dev_port=$((5172 + agent_slot))
    dim "Dev server port: ${dev_port} (CSB_DEV_PORT)"

    # Set up PATH and CSB_DEV_PORT for the agent user
    limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" bash -c "
        if ! grep -q npm-global ~/.bashrc 2>/dev/null; then
            echo 'export PATH=\"/home/ubuntu/.npm-global/bin:\$PATH\"' >> ~/.bashrc
        fi
        if ! grep -q CSB_DEV_PORT ~/.bashrc 2>/dev/null; then
            echo 'export CSB_DEV_PORT=${dev_port}' >> ~/.bashrc
        fi
    "

    # Clone or update repo
    if [[ -n "${git_remote}" ]]; then
        info "Syncing repository..."
        limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" bash -c "
            if [ ! -d ~/repo/.git ]; then
                git clone '${git_remote}' ~/repo
            else
                cd ~/repo && git fetch origin && git rebase origin/main || git rebase origin/master || true
            fi
        "
    else
        warn "No git remote found - agent will have empty workspace"
        limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" mkdir -p "/home/${agent_name}/repo"
    fi

    # Check if session already exists
    if limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" tmux has-session -t "${agent_name}" 2>/dev/null; then
        info "Attaching to existing session: ${agent_name}"
    else
        info "Creating session: ${agent_name}"

        # Create tmux session as the agent user
        if ! limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" tmux new-session -d -s "${agent_name}" -c "/home/${agent_name}/repo"; then
            error "Failed to create tmux session '${agent_name}'"
            exit 1
        fi

        # Remove settings.json which can cause Claude to panic
        limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" rm -f "/home/${agent_name}/.claude/settings.json"

        # Send claude command to the session
        limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" tmux send-keys -t "${agent_name}" "claude --dangerously-skip-permissions" Enter
    fi

    # Attach to the session
    info "Attaching to ${agent_name}..."
    limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_name}" tmux attach-session -t "${agent_name}"
}

# Command: create
cmd_create() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        create_vm "${vm_name}"
    fi

    start_vm "${vm_name}"

    # Create new tmux session with bash, then send claude command
    # This ensures the session persists even if claude exits
    local session_name=$(get_next_session "${vm_name}")
    info "Creating session: ${session_name}"

    if ! limactl shell --workdir / "${vm_name}" -- tmux new-session -d -s "${session_name}" -c /workspace; then
        error "Failed to create tmux session '${session_name}'"
        exit 1
    fi

    # Remove settings.json which can cause Claude to panic (Claude bug)
    limactl shell --workdir / "${vm_name}" -- rm -f '$HOME/.claude/settings.json'

    # Send claude command to the session (skip permissions since VM is sandboxed)
    limactl shell --workdir / "${vm_name}" -- tmux send-keys -t "${session_name}" "claude --dangerously-skip-permissions" Enter

    # Attach to the session
    info "Attaching to ${session_name}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session_name}"
}

# Command: start (from golden image)
# Usage: csb start [agent-name]
#   Without agent-name: creates claude-N session in /workspace (shared mount)
#   With agent-name: creates isolated agent with own user and repo clone
cmd_start() {
    check_lima
    local vm_name=$(get_vm_name)
    local arch=$(uname -m)
    local golden_image="${CSB_DIR}/golden-${arch}.qcow2"
    local agent_name="${1:-}"

    # Require golden image exists
    if [[ ! -f "${golden_image}" ]]; then
        error "No golden image found: ${golden_image}"
        echo "Run 'csb create' to provision a VM, then 'csb snapshot' to create a golden image."
        exit 1
    fi

    # Create VM from golden if it doesn't exist
    if ! vm_exists "${vm_name}"; then
        create_vm_from_golden "${vm_name}"
    fi

    # Start VM (no provisioning progress since golden is pre-provisioned)
    local status=$(vm_status "${vm_name}")
    if [[ "${status}" != "Running" ]]; then
        run_with_spinner "Starting VM" "VM started" \
            limactl start --tty=false "${vm_name}"
    fi

    # If agent name provided, use isolated agent mode
    if [[ -n "${agent_name}" ]]; then
        local git_remote=$(get_git_remote)
        start_agent "${vm_name}" "${agent_name}" "${git_remote}"
        return
    fi

    # Default mode: shared workspace with claude-N sessions
    local session_name=$(get_next_session "${vm_name}")
    info "Creating session: ${session_name}"

    if ! limactl shell --workdir / "${vm_name}" -- tmux new-session -d -s "${session_name}" -c /workspace; then
        error "Failed to create tmux session '${session_name}'"
        exit 1
    fi

    # Remove settings.json which can cause Claude to panic (Claude bug)
    limactl shell --workdir / "${vm_name}" -- rm -f '$HOME/.claude/settings.json'

    # Send claude command to the session (skip permissions since VM is sandboxed)
    limactl shell --workdir / "${vm_name}" -- tmux send-keys -t "${session_name}" "claude --dangerously-skip-permissions" Enter

    # Attach to the session
    info "Attaching to ${session_name}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session_name}"
}

# Command: stop
cmd_stop() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}"

    stop_vm "${vm_name}"
}

# Command: snapshot
cmd_snapshot() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb create' first."

    # Stop VM if running
    local status=$(vm_status "${vm_name}")
    if [[ "${status}" == "Running" ]]; then
        stop_vm "${vm_name}"
    fi

    # Flatten diffdisk to golden image
    local arch=$(uname -m)
    local golden_image="${CSB_DIR}/golden-${arch}.qcow2"
    local diffdisk="${HOME}/.lima/${vm_name}/diffdisk"

    if [[ ! -f "${diffdisk}" ]]; then
        error "VM disk not found: ${diffdisk}"
        exit 1
    fi

    info "Creating golden image: ${golden_image}"
    run_with_spinner "Flattening disk" "Golden image created: ${golden_image}" \
        qemu-img convert -O qcow2 "${diffdisk}" "${golden_image}"
}

# Command: shell
cmd_shell() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    start_vm "${vm_name}"
    limactl shell --workdir /workspace "${vm_name}"
}

# Command: logs
cmd_logs() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    start_vm "${vm_name}"
    limactl shell --workdir / "${vm_name}" -- sudo cat /var/log/cloud-init-output.log
}

# Command: attach
# Usage: csb attach [session]
#   session can be: number (for claude-N), or agent name
cmd_attach() {
    check_lima
    local session="${1:-}"
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    start_vm "${vm_name}"

    if [[ -z "${session}" ]]; then
        # Attach to most recent claude-N session
        local latest=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)
        if [[ -z "${latest}" ]]; then
            error "No Claude sessions found. Run 'csb start' to create one."
            exit 1
        fi
        session="${latest}"
        info "Attaching to ${session}..."
        limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session}"
    elif [[ "${session}" =~ ^[0-9]+$ ]]; then
        # Numeric session: claude-N
        session="claude-${session}"
        info "Attaching to ${session}..."
        limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session}"
    else
        # Named agent session: attach as that user
        info "Attaching to agent ${session}..."
        limactl shell --workdir / "${vm_name}" -- sudo -u "${session}" tmux attach-session -t "${session}"
    fi
}

# Command: list
cmd_list() {
    check_lima
    local vm_name=$(get_vm_name)

    echo "VM: ${vm_name}"
    echo "Status: $(vm_status "${vm_name}")"
    echo ""

    if vm_exists "${vm_name}" && [[ "$(vm_status "${vm_name}")" == "Running" ]]; then
        local has_sessions=false

        # Get shared sessions (claude-N) from default user
        local claude_sessions=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' || true)

        if [[ -n "${claude_sessions}" ]]; then
            has_sessions=true
            echo "Shared sessions (in /workspace):"
            echo "${claude_sessions}" | while read -r s; do echo "  ${s}"; done
        fi

        # Get agent sessions - each agent user has their own tmux server
        # List home directories, exclude system users (ubuntu, *.linux)
        local agent_users=$(limactl shell --workdir / "${vm_name}" -- ls /home 2>/dev/null | grep -vE '^(ubuntu|.*\.linux)$' || true)

        if [[ -n "${agent_users}" ]]; then
            local agent_header_shown=false
            while read -r agent_user; do
                [[ -z "${agent_user}" ]] && continue
                # Check if this user has a tmux session
                # Note: < /dev/null prevents limactl from consuming stdin (the while loop input)
                local agent_session=$(limactl shell --workdir / "${vm_name}" -- sudo -u "${agent_user}" tmux list-sessions -F '#{session_name}' < /dev/null 2>/dev/null || true)
                if [[ -n "${agent_session}" ]]; then
                    if [[ "${agent_header_shown}" == "false" ]]; then
                        [[ "${has_sessions}" == "true" ]] && echo ""
                        echo "Isolated agents (separate users):"
                        agent_header_shown=true
                    fi
                    has_sessions=true
                    local agent_slot=$(get_agent_slot "${vm_name}" "${agent_user}")
                    local dev_port=$((5172 + agent_slot))
                    echo "  ${agent_user} (port ${dev_port})"
                fi
            done <<< "${agent_users}"
        fi

        if [[ "${has_sessions}" == "false" ]]; then
            echo "No sessions running"
        fi
    fi
}

# Command: status
cmd_status() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        echo "No VM configured for this directory"
        exit 0
    fi

    local status=$(vm_status "${vm_name}")
    echo "VM: ${vm_name}"
    echo "Status: ${status}"

    if [[ -f "${CSB_FILE}" ]]; then
        echo ""
        echo "Config:"
        tail -n +2 "${CSB_FILE}"
    fi
}

# Command: config
cmd_config() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    info "Edit VM configuration with Lima:"
    echo "  limactl edit ${vm_name}"
    echo ""
    echo "Note: Changes require VM restart (csb stop && csb start)"
}

# Command: destroy
cmd_destroy() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}"

    warn "This will permanently delete the VM: ${vm_name}"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "${vm_name}"
        rm -f "${CSB_FILE}"
        success "VM destroyed"
    else
        info "Cancelled"
    fi
}

# Command: help
cmd_help() {
    cat << EOF
csb - Claude SandBox v${VERSION}

Usage: csb [--verbose] <command> [options]

Commands:
  create           Provision VM from scratch and start Claude session
  start [agent]    Start from golden image (fast, requires prior snapshot)
                   Without agent: shared session in /workspace (claude-N)
                   With agent: isolated user with own repo clone
  stop             Shut down the VM
  snapshot         Save VM state as golden image for fast startup
  shell            Open bash shell inside VM
  logs             View VM provisioning logs
  attach [n|name]  Attach to session (number for claude-N, name for agent)
  list             Show VM status and all sessions
  status           Show VM state
  config           Show how to edit VM resources
  destroy          Permanently delete the VM
  help             Show this help message

Options:
  --verbose, -v    Show detailed output from Lima commands

Examples:
  csb create            # Provision VM from scratch (slow, first time)
  csb snapshot          # Save provisioned state as golden image
  csb start             # Start shared session in /workspace
  csb start agent1      # Start isolated agent (own user, cloned repo)
  csb start agent2      # Start another isolated agent in parallel
  csb attach 1          # Attach to session claude-1
  csb attach agent1     # Attach to agent1's session
  csb list              # Show all sessions (shared and agents)
  csb shell             # Open shell in VM
  csb stop              # Stop the VM

Environment:
  ANTHROPIC_API_KEY   API key for Claude (passed to VM)
  GITHUB_TOKEN        GitHub token for git HTTPS authentication
  CSB_VERBOSE=true    Enable verbose output

Parallel Agents:
  Each agent gets its own Linux user with isolated home directory.
  Agents cannot see each other's files (kernel-enforced via chmod 700).
  Git repo is cloned to ~/repo for each agent (requires GITHUB_TOKEN).

  Port Mapping:
  Each agent gets a consistent dev port via CSB_DEV_PORT environment variable.
  agent1 -> 5173, agent2 -> 5174, etc. (based on trailing number in name).
  Configure your dev server to use this port for predictable URLs.

Notes:
  Claude runs with --dangerously-skip-permissions since the VM itself
  provides sandboxing (network allowlist, isolated filesystem).

EOF
}

# Main
main() {
    # Parse global flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd="${1:-help}"
    shift || true

    case "${cmd}" in
        create)   cmd_create "$@" ;;
        start)    cmd_start "$@" ;;
        stop)     cmd_stop "$@" ;;
        snapshot) cmd_snapshot "$@" ;;
        shell)    cmd_shell "$@" ;;
        logs)    cmd_logs "$@" ;;
        attach)  cmd_attach "$@" ;;
        list)    cmd_list "$@" ;;
        status)  cmd_status "$@" ;;
        config)  cmd_config "$@" ;;
        destroy) cmd_destroy "$@" ;;
        help|-h|--help) cmd_help ;;
        version|--version) echo "csb v${VERSION}" ;;
        *)
            error "Unknown command: ${cmd}"
            echo "Run 'csb help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
