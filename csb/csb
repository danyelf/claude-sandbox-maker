#!/bin/bash
# csb - Claude SandBox
# Lima-powered sandboxed environment for Claude Code development

set -e

VERSION="0.1.0"
CSB_DIR="${HOME}/.csb"
CSB_FILE=".csb"
TEMPLATE_FILE="${CSB_DIR}/template.yaml"
NETWORK_RULES="${CSB_DIR}/network-rules.sh"
VERBOSE="${CSB_VERBOSE:-false}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Print colored message
info() { echo -e "${BLUE}[csb]${NC} $1"; }
success() { echo -e "${GREEN}[csb]${NC} $1"; }
warn() { echo -e "${YELLOW}[csb]${NC} $1"; }
error() { echo -e "${RED}[csb]${NC} $1" >&2; }
dim() { echo -e "${GRAY}     $1${NC}"; }

# Spinner for long-running operations
spinner_pid=""
start_spinner() {
    local msg="$1"
    if [[ "${VERBOSE}" == "true" ]]; then
        info "$msg"
        return
    fi

    (
        local chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
        local i=0
        while true; do
            printf "\r${BLUE}[csb]${NC} %s %s" "$msg" "${chars:$i:1}"
            i=$(( (i + 1) % 10 ))
            sleep 0.1
        done
    ) &
    spinner_pid=$!
    disown $spinner_pid 2>/dev/null
}

stop_spinner() {
    local success="${1:-true}"
    local msg="${2:-}"

    if [[ -n "$spinner_pid" ]]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null || true
        spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi

    if [[ -n "$msg" ]]; then
        if [[ "$success" == "true" ]]; then
            success "$msg"
        else
            error "$msg"
        fi
    fi
}

# Run command with spinner (suppresses output unless verbose or error)
run_with_spinner() {
    local msg="$1"
    shift
    local success_msg="${1:-}"
    shift

    start_spinner "$msg"

    local output
    local exit_code
    if [[ "${VERBOSE}" == "true" ]]; then
        stop_spinner true ""
        info "$msg"
        "$@"
        exit_code=$?
    else
        output=$("$@" 2>&1)
        exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        stop_spinner true "${success_msg:-$msg... done}"
    else
        stop_spinner false "$msg... failed"
        if [[ -n "$output" ]]; then
            echo "$output" >&2
        fi
        return $exit_code
    fi
}

# Cleanup spinner on exit
trap 'stop_spinner false ""' EXIT

# Check if Lima is installed
check_lima() {
    if ! command -v limactl &> /dev/null; then
        error "Lima is not installed. Please install it first:"
        echo "  brew install lima"
        exit 1
    fi
}

# Generate VM name from directory path
generate_vm_name() {
    local hash=$(echo -n "$(pwd)" | shasum | cut -c1-6)
    echo "csb-${hash}"
}

# Get or create VM name for current directory
get_vm_name() {
    if [[ -f "${CSB_FILE}" ]]; then
        head -n 1 "${CSB_FILE}"
    else
        generate_vm_name
    fi
}

# Save VM config
save_config() {
    local vm_name="$1"
    echo "${vm_name}" > "${CSB_FILE}"
    echo "# csb config - do not edit manually" >> "${CSB_FILE}"
    echo "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${CSB_FILE}"
    echo "workspace=$(pwd)" >> "${CSB_FILE}"
}

# Check if VM exists
vm_exists() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -e ".[] | select(.name == \"${vm_name}\")" > /dev/null 2>&1
}

# Get VM status
vm_status() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -r ".[] | select(.name == \"${vm_name}\") | .status" 2>/dev/null || echo "NotFound"
}

# Create VM from template
create_vm() {
    local vm_name="$1"
    local workspace="$(pwd)"

    info "Creating VM: ${vm_name}"
    dim "This may take a few minutes on first run..."
    echo ""

    # Ensure CSB directory exists
    mkdir -p "${CSB_DIR}"

    # Check if template exists, if not copy it
    if [[ ! -f "${TEMPLATE_FILE}" ]]; then
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ -f "${script_dir}/template.yaml" ]]; then
            cp "${script_dir}/template.yaml" "${TEMPLATE_FILE}"
            cp "${script_dir}/network-rules.sh" "${NETWORK_RULES}"
        else
            error "Template not found. Please run 'csb init' first or reinstall csb."
            exit 1
        fi
    fi

    # Create temporary template with workspace substituted
    local tmp_template=$(mktemp)
    sed "s|{{WORKSPACE_PATH}}|${workspace}|g" "${TEMPLATE_FILE}" > "${tmp_template}"

    # Substitute API key if set
    if [[ -n "${ANTHROPIC_API_KEY}" ]]; then
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}|${ANTHROPIC_API_KEY}|g" "${tmp_template}"
    else
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}||g" "${tmp_template}"
    fi
    rm -f "${tmp_template}.bak"

    # Create the VM with progress feedback
    run_with_spinner "Downloading VM image" "VM image ready" \
        limactl create --name="${vm_name}" "${tmp_template}"
    rm -f "${tmp_template}"

    # Save config
    save_config "${vm_name}"

    echo ""
    success "VM created: ${vm_name}"
}

# Start VM
start_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" == "Running" ]]; then
        info "VM already running"
        return 0
    fi

    run_with_spinner "Starting VM (provisioning tools)" "VM started" \
        limactl start "${vm_name}"
}

# Stop VM
stop_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" != "Running" ]]; then
        info "VM is not running"
        return 0
    fi

    run_with_spinner "Stopping VM" "VM stopped" \
        limactl stop "${vm_name}"
}

# Get next tmux session number
get_next_session() {
    local vm_name="$1"
    local sessions=$(limactl shell "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)

    if [[ -z "${sessions}" ]]; then
        echo "claude-1"
    else
        local num=$(echo "${sessions}" | sed 's/claude-//')
        echo "claude-$((num + 1))"
    fi
}

# List tmux sessions
list_sessions() {
    local vm_name="$1"
    limactl shell "${vm_name}" -- tmux list-sessions 2>/dev/null || echo "No sessions"
}

# Command: start
cmd_start() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        create_vm "${vm_name}"
    fi

    start_vm "${vm_name}"

    # Create new tmux session with Claude
    local session_name=$(get_next_session "${vm_name}")
    info "Creating session: ${session_name}"

    limactl shell "${vm_name}" -- tmux new-session -d -s "${session_name}" -c /workspace "claude" 2>/dev/null || true

    # Attach to the session
    info "Attaching to ${session_name}..."
    limactl shell "${vm_name}" -- tmux attach-session -t "${session_name}"
}

# Command: stop
cmd_stop() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory"
        exit 1
    fi

    stop_vm "${vm_name}"
}

# Command: shell
cmd_shell() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    start_vm "${vm_name}"
    limactl shell "${vm_name}" --workdir /workspace
}

# Command: attach
cmd_attach() {
    check_lima
    local session="${1:-}"
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    start_vm "${vm_name}"

    if [[ -z "${session}" ]]; then
        # Attach to most recent session
        local latest=$(limactl shell "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)
        if [[ -z "${latest}" ]]; then
            error "No Claude sessions found. Run 'csb start' to create one."
            exit 1
        fi
        session="${latest}"
    elif [[ "${session}" =~ ^[0-9]+$ ]]; then
        session="claude-${session}"
    fi

    info "Attaching to ${session}..."
    limactl shell "${vm_name}" -- tmux attach-session -t "${session}"
}

# Command: list
cmd_list() {
    check_lima
    local vm_name=$(get_vm_name)

    echo "VM: ${vm_name}"
    echo "Status: $(vm_status "${vm_name}")"
    echo ""

    if vm_exists "${vm_name}" && [[ "$(vm_status "${vm_name}")" == "Running" ]]; then
        echo "Sessions:"
        list_sessions "${vm_name}"
    fi
}

# Command: status
cmd_status() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        echo "No VM configured for this directory"
        exit 0
    fi

    local status=$(vm_status "${vm_name}")
    echo "VM: ${vm_name}"
    echo "Status: ${status}"

    if [[ -f "${CSB_FILE}" ]]; then
        echo ""
        echo "Config:"
        cat "${CSB_FILE}" | tail -n +2
    fi
}

# Command: config
cmd_config() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "${key}" ]]; then
        echo "Usage: csb config <key> <value>"
        echo ""
        echo "Keys:"
        echo "  cpus     Number of CPUs (e.g., 4)"
        echo "  memory   Memory size (e.g., 4GiB)"
        echo "  disk     Disk size (e.g., 50GiB)"
        echo ""
        echo "Note: Changes require VM restart (csb stop && csb start)"
        exit 0
    fi

    warn "VM configuration changes require editing Lima config directly."
    echo "Run: limactl edit ${vm_name}"
}

# Command: destroy
cmd_destroy() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory"
        exit 1
    fi

    warn "This will permanently delete the VM: ${vm_name}"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "${vm_name}"
        rm -f "${CSB_FILE}"
        success "VM destroyed"
    else
        info "Cancelled"
    fi
}

# Command: init
cmd_init() {
    info "Initializing csb..."

    mkdir -p "${CSB_DIR}"

    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [[ -f "${script_dir}/template.yaml" ]]; then
        cp "${script_dir}/template.yaml" "${TEMPLATE_FILE}"
        success "Copied template.yaml"
    fi

    if [[ -f "${script_dir}/network-rules.sh" ]]; then
        cp "${script_dir}/network-rules.sh" "${NETWORK_RULES}"
        chmod +x "${NETWORK_RULES}"
        success "Copied network-rules.sh"
    fi

    success "csb initialized at ${CSB_DIR}"
}

# Command: help
cmd_help() {
    cat << EOF
csb - Claude SandBox v${VERSION}

Usage: csb [--verbose] <command> [options]

Commands:
  start          Create new Claude session and attach (creates VM on first run)
  stop           Shut down the VM
  shell          Open bash shell inside VM
  attach [n]     Attach to session n (or most recent if n not specified)
  list           Show VM status and all sessions
  status         Show VM state
  config         Adjust VM resources (requires restart)
  destroy        Permanently delete the VM
  init           Initialize csb config directory
  help           Show this help message

Options:
  --verbose, -v  Show detailed output from Lima commands

Examples:
  csb start           # Start Claude in sandbox (creates VM if needed)
  csb --verbose start # Start with detailed Lima output
  csb attach 1        # Attach to session claude-1
  csb shell           # Open shell in VM
  csb stop            # Stop the VM

Environment:
  ANTHROPIC_API_KEY   API key for Claude (passed to VM)
  CSB_VERBOSE=true    Enable verbose output

EOF
}

# Main
main() {
    # Parse global flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-V)
                VERBOSE=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd="${1:-help}"
    shift || true

    case "${cmd}" in
        start)   cmd_start "$@" ;;
        stop)    cmd_stop "$@" ;;
        shell)   cmd_shell "$@" ;;
        attach)  cmd_attach "$@" ;;
        list)    cmd_list "$@" ;;
        status)  cmd_status "$@" ;;
        config)  cmd_config "$@" ;;
        destroy) cmd_destroy "$@" ;;
        init)    cmd_init "$@" ;;
        help|-h|--help) cmd_help ;;
        version|--version) echo "csb v${VERSION}" ;;
        *)
            error "Unknown command: ${cmd}"
            echo "Run 'csb help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
