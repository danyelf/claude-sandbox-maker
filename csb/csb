#!/bin/bash
# csb - Claude SandBox
# Lima-powered sandboxed environment for Claude Code development

set -e

VERSION="0.1.0"
CSB_DIR="${HOME}/.csb"
CSB_FILE=".csb"
TEMPLATE_FILE="${CSB_DIR}/template.yaml"
VERBOSE="${CSB_VERBOSE:-false}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Print colored message
info() { echo -e "${BLUE}[csb]${NC} $1"; }
success() { echo -e "${GREEN}[csb]${NC} $1"; }
warn() { echo -e "${YELLOW}[csb]${NC} $1"; }
error() { echo -e "${RED}[csb]${NC} $1" >&2; }
dim() { echo -e "${GRAY}     $1${NC}"; }

# Spinner animation constants
SPINNER_CHARS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
SPINNER_DELAY=0.1

# Core spinner loop - runs in subshell, renders spinner with optional timing
# Args: statefile (empty for simple mode), message (for simple mode)
_spinner_loop() {
    local statefile="$1"
    local static_msg="$2"
    local i=0
    local stime=$(date +%s)

    while true; do
        local msg elapsed_str=""
        if [[ -n "$statefile" ]]; then
            [[ -f "$statefile" ]] || break
            msg=$(head -1 "$statefile" 2>/dev/null || echo "Starting")
            local elapsed=$(($(date +%s) - stime))
            if [[ $elapsed -lt 60 ]]; then
                elapsed_str=" ${GRAY}[${elapsed}s]${NC}"
            else
                elapsed_str=" ${GRAY}[$((elapsed / 60))m $((elapsed % 60))s]${NC}"
            fi
        else
            msg="$static_msg"
        fi
        echo -en "\r${BLUE}[csb]${NC} ${msg} ${SPINNER_CHARS:$i:1}${elapsed_str}"
        i=$(( (i + 1) % ${#SPINNER_CHARS} ))
        sleep $SPINNER_DELAY
    done
}

# Simple spinner for short operations
spinner_pid=""
start_spinner() {
    local msg="$1"
    if [[ "${VERBOSE}" == "true" ]]; then
        info "$msg"
        return
    fi
    _spinner_loop "" "$msg" &
    spinner_pid=$!
    disown $spinner_pid 2>/dev/null
}

stop_spinner() {
    local success="${1:-true}"
    local msg="${2:-}"

    if [[ -n "$spinner_pid" ]]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null || true
        spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi

    if [[ -n "$msg" ]]; then
        if [[ "$success" == "true" ]]; then
            success "$msg"
        else
            error "$msg"
        fi
    fi
}

# Progress spinner with timing - for long operations with stage updates
progress_spinner_statefile=""
progress_spinner_pid=""

start_progress_spinner() {
    local initial_stage="$1"

    progress_spinner_statefile=$(mktemp)
    echo "${initial_stage}" > "${progress_spinner_statefile}"

    _spinner_loop "$progress_spinner_statefile" "" &
    progress_spinner_pid=$!
    disown $progress_spinner_pid 2>/dev/null
}

update_progress_spinner() {
    local new_stage="$1"
    if [[ -n "${progress_spinner_statefile}" && -f "${progress_spinner_statefile}" ]]; then
        echo "${new_stage}" > "${progress_spinner_statefile}"
    fi
}

stop_progress_spinner() {
    if [[ -n "${progress_spinner_statefile}" ]]; then
        rm -f "${progress_spinner_statefile}"
        progress_spinner_statefile=""
    fi
    if [[ -n "${progress_spinner_pid}" ]]; then
        kill $progress_spinner_pid 2>/dev/null
        wait $progress_spinner_pid 2>/dev/null || true
        progress_spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi
}

# Run command with spinner (suppresses output unless verbose or error)
run_with_spinner() {
    local msg="$1"
    shift
    local success_msg="${1:-}"
    shift

    start_spinner "$msg"

    local output
    local exit_code=0
    if [[ "${VERBOSE}" == "true" ]]; then
        stop_spinner true ""
        info "$msg"
        "$@" || exit_code=$?
    else
        output=$("$@" 2>&1) || exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        stop_spinner true "${success_msg:-$msg... done}"
        return 0
    else
        stop_spinner false "$msg... failed"
        if [[ -n "$output" ]]; then
            echo "$output" >&2
        fi
        # Exit directly to ensure error is visible before set -e kills us
        exit $exit_code
    fi
}

# Cleanup function for all spinners
cleanup_spinners() {
    stop_spinner false "" 2>/dev/null
    stop_progress_spinner 2>/dev/null
}

# Trap EXIT, INT (Ctrl+C), and TERM signals
trap cleanup_spinners EXIT INT TERM

# Escape string for use in sed replacement (handles |, &, \, newlines)
escape_sed_replacement() {
    printf '%s' "$1" | sed -e 's/[&\|]/\\&/g' -e 's/$/\\/' | tr -d '\n' | sed 's/\\$//'
}

# Format seconds as human-readable duration
format_duration() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s"
    else
        local mins=$((seconds / 60))
        local secs=$((seconds % 60))
        echo "${mins}m ${secs}s"
    fi
}

# Check if Lima is installed
check_lima() {
    if ! command -v limactl &> /dev/null; then
        error "Lima is not installed. Please install it first:"
        echo "  brew install lima"
        exit 1
    fi
}

# Generate VM name from directory path
generate_vm_name() {
    local hash=$(echo -n "$(pwd)" | shasum | cut -c1-6)
    echo "csb-${hash}"
}

# Get or create VM name for current directory
get_vm_name() {
    if [[ -f "${CSB_FILE}" ]]; then
        head -n 1 "${CSB_FILE}"
    else
        generate_vm_name
    fi
}

# Save VM config
save_config() {
    local vm_name="$1"
    echo "${vm_name}" > "${CSB_FILE}"
    echo "# csb config - do not edit manually" >> "${CSB_FILE}"
    echo "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${CSB_FILE}"
    echo "workspace=$(pwd)" >> "${CSB_FILE}"
}

# Check if VM exists
vm_exists() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    limactl list --json 2>/dev/null | jq -e "select(.name == \"${vm_name}\")" > /dev/null 2>&1
}

# Require VM to exist, exit with error if not
require_vm() {
    local vm_name="$1"
    local msg="${2:-No VM found for this directory}"
    if ! vm_exists "${vm_name}"; then
        error "${msg}"
        exit 1
    fi
}

# Get VM status
vm_status() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    local status=$(limactl list --json 2>/dev/null | jq -r "select(.name == \"${vm_name}\") | .status" 2>/dev/null)
    echo "${status:-NotFound}"
}

# Create VM from template
create_vm() {
    local vm_name="$1"
    local workspace="$(pwd)"
    local create_start_time=$(date +%s)

    info "Creating VM: ${vm_name}"
    dim "This may take a few minutes on first run..."
    echo ""

    # Ensure CSB directory exists
    mkdir -p "${CSB_DIR}"

    # Check if template exists, if not copy it
    if [[ ! -f "${TEMPLATE_FILE}" ]]; then
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ -f "${script_dir}/template.yaml" ]]; then
            cp "${script_dir}/template.yaml" "${TEMPLATE_FILE}"
        else
            error "Template not found. Please reinstall csb."
            exit 1
        fi
    fi

    # Create temporary template with workspace substituted
    local tmp_template=$(mktemp)
    local escaped_workspace=$(escape_sed_replacement "${workspace}")
    sed "s|{{WORKSPACE_PATH}}|${escaped_workspace}|g" "${TEMPLATE_FILE}" > "${tmp_template}"

    # Substitute API key if set
    if [[ -n "${ANTHROPIC_API_KEY}" ]]; then
        local escaped_key=$(escape_sed_replacement "${ANTHROPIC_API_KEY}")
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}|${escaped_key}|g" "${tmp_template}"
    else
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}||g" "${tmp_template}"
    fi
    rm -f "${tmp_template}.bak"

    # Create the VM with progress feedback (--tty=false skips interactive prompts)
    run_with_spinner "Downloading VM image" "VM image ready" \
        limactl create --tty=false --name="${vm_name}" "${tmp_template}"
    rm -f "${tmp_template}"

    # Save config
    save_config "${vm_name}"

    local create_elapsed=$(($(date +%s) - create_start_time))
    local create_duration=$(format_duration $create_elapsed)
    echo ""
    success "VM created: ${vm_name} ${GRAY}(${create_duration})${NC}"
}

# Start VM with progress display
# Polls cloud-init log for CSB_PROGRESS markers
start_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" == "Running" ]]; then
        info "VM already running"
        return 0
    fi

    info "Starting VM: ${vm_name}"
    dim "First start provisions the VM (this takes a few minutes)..."
    echo ""

    if [[ "${VERBOSE}" == "true" ]]; then
        # Verbose mode: show all output
        limactl start --tty=false --progress "${vm_name}"
    else
        # Normal mode: show progress with spinner and timing
        local tmpfile=$(mktemp)
        local exit_code=0
        local last_stage=""
        local current_stage="Booting VM"

        # Timing tracking
        local start_time=$(date +%s)
        local stage_start_time=$start_time

        # Start progress spinner (runs at 0.1s for smooth animation)
        start_progress_spinner "${current_stage}"

        # Start limactl in background (without --progress to avoid noise)
        limactl start --tty=false "${vm_name}" > "${tmpfile}" 2>&1 &
        local lima_pid=$!
        disown $lima_pid 2>/dev/null

        # Monitor progress by polling cloud-init log via SSH (1s interval)
        while kill -0 $lima_pid 2>/dev/null; do
            # Try to get latest progress and check for errors from VM's cloud-init log
            local new_stage=""
            local error_marker=""
            if limactl shell --workdir / "${vm_name}" -- sudo test -f /var/log/cloud-init-output.log 2>/dev/null; then
                new_stage=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_PROGRESS:' /var/log/cloud-init-output.log 2>/dev/null | tail -1 | sed 's/.*CSB_PROGRESS://' || true)
                # Check for explicit error markers from provisioning scripts
                error_marker=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_ERROR:' /var/log/cloud-init-output.log 2>/dev/null | tail -1 | sed 's/.*CSB_ERROR://' || true)
            fi

            # Handle explicit error markers (immediate failure detection)
            if [[ -n "${error_marker}" ]]; then
                stop_progress_spinner
                error "✗ ${current_stage} failed"
                echo ""
                error "Error: ${error_marker}"
                echo "" >&2
                error "Last lines of provisioning output:"
                limactl shell --workdir / "${vm_name}" -- sudo tail -30 /var/log/cloud-init-output.log 2>/dev/null >&2 || true
                kill $lima_pid 2>/dev/null || true
                rm -f "${tmpfile}"
                exit 1
            fi

            if [[ -n "${new_stage}" && "${new_stage}" != "${last_stage}" ]]; then
                # Calculate elapsed time for completed stage
                local now=$(date +%s)
                local stage_elapsed=$((now - stage_start_time))
                local stage_duration=$(format_duration $stage_elapsed)

                # Show completed stage with timing
                stop_progress_spinner
                success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"

                # Start timing new stage
                current_stage="${new_stage}"
                last_stage="${new_stage}"
                stage_start_time=$now

                # Restart spinner with new stage
                start_progress_spinner "${current_stage}"
            fi

            # Check if cloud-init has failed (provisioning script error)
            local cloud_init_status=""
            cloud_init_status=$(limactl shell --workdir / "${vm_name}" -- sudo cat /run/cloud-init/result.json 2>/dev/null || true)
            if [[ -n "${cloud_init_status}" ]]; then
                # result.json exists - check if there were errors
                local has_errors=""
                has_errors=$(echo "${cloud_init_status}" | jq -r '.v1.errors | length' 2>/dev/null || echo "0")
                if [[ "${has_errors}" != "0" ]]; then
                    # Cloud-init completed with errors - extract error details
                    stop_progress_spinner
                    error "✗ ${current_stage} failed"
                    echo ""

                    # Show cloud-init errors
                    local error_msgs=""
                    error_msgs=$(echo "${cloud_init_status}" | jq -r '.v1.errors[]' 2>/dev/null || true)
                    if [[ -n "${error_msgs}" ]]; then
                        error "Cloud-init errors:"
                        echo "${error_msgs}" >&2
                    fi

                    # Show last part of cloud-init log for context
                    echo "" >&2
                    error "Last lines of provisioning output:"
                    limactl shell --workdir / "${vm_name}" -- sudo tail -30 /var/log/cloud-init-output.log 2>/dev/null >&2 || true

                    # Kill the lima process and cleanup
                    kill $lima_pid 2>/dev/null || true
                    rm -f "${tmpfile}"
                    exit 1
                fi
            fi

            sleep 1
        done

        # Stop spinner and get exit code
        stop_progress_spinner
        wait $lima_pid || exit_code=$?

        # Calculate final timing
        local end_time=$(date +%s)
        local final_stage_elapsed=$((end_time - stage_start_time))
        local total_elapsed=$((end_time - start_time))
        local stage_duration=$(format_duration $final_stage_elapsed)
        local total_duration=$(format_duration $total_elapsed)

        if [[ $exit_code -eq 0 ]]; then
            success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"
            echo ""
            success "VM started ${GRAY}(total: ${total_duration})${NC}"

            # Check for any warnings from provisioning
            local warnings
            warnings=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_WARN:' /var/log/cloud-init-output.log 2>/dev/null | sed 's/.*CSB_WARN://' || true)
            if [[ -n "${warnings}" ]]; then
                echo ""
                while IFS= read -r warning_msg; do
                    warn "⚠ ${warning_msg}"
                done <<< "${warnings}"
            fi
        else
            # limactl exited with error - but check if VM is actually running
            # (Lima 2.0 has a bug where it times out waiting for "running" event
            # even when the VM is running and provisioned)
            local actual_status=$(vm_status "${vm_name}")
            if [[ "${actual_status}" == "Running" ]]; then
                # VM is running despite limactl error - check if cloud-init finished
                local cloud_init_done=""
                cloud_init_done=$(limactl shell --workdir / "${vm_name}" -- sudo cat /run/cloud-init/result.json 2>/dev/null || true)
                if [[ -n "${cloud_init_done}" ]]; then
                    # Cloud-init finished - treat as success
                    warn "limactl reported timeout, but VM is running"
                    success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"
                    echo ""
                    success "VM started ${GRAY}(total: ${total_duration})${NC}"

                    # Check for any warnings from provisioning
                    local warnings
                    warnings=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_WARN:' /var/log/cloud-init-output.log 2>/dev/null | sed 's/.*CSB_WARN://' || true)
                    if [[ -n "${warnings}" ]]; then
                        echo ""
                        while IFS= read -r warning_msg; do
                            warn "⚠ ${warning_msg}"
                        done <<< "${warnings}"
                    fi
                    rm -f "${tmpfile}"
                    return 0
                fi
            fi

            # VM is not running or cloud-init didn't finish - actual failure
            error "Failed to start VM after ${total_duration}"
            echo ""
            # Show output for debugging
            cat "${tmpfile}" >&2
            rm -f "${tmpfile}"
            exit $exit_code
        fi

        rm -f "${tmpfile}"
    fi
}

# Stop VM
stop_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" != "Running" ]]; then
        info "VM is not running"
        return 0
    fi

    run_with_spinner "Stopping VM" "VM stopped" \
        limactl stop "${vm_name}"
}

# Get next tmux session number
get_next_session() {
    local vm_name="$1"
    local sessions=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)

    if [[ -z "${sessions}" ]]; then
        echo "claude-1"
    else
        local num=$(echo "${sessions}" | sed 's/claude-//')
        echo "claude-$((num + 1))"
    fi
}

# List tmux sessions
list_sessions() {
    local vm_name="$1"
    limactl shell --workdir / "${vm_name}" -- tmux list-sessions 2>/dev/null || echo "No sessions"
}

# Command: start
cmd_start() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        create_vm "${vm_name}"
    fi

    start_vm "${vm_name}"

    # Create new tmux session with bash, then send claude command
    # This ensures the session persists even if claude exits
    local session_name=$(get_next_session "${vm_name}")
    info "Creating session: ${session_name}"

    if ! limactl shell --workdir / "${vm_name}" -- tmux new-session -d -s "${session_name}" -c /workspace; then
        error "Failed to create tmux session '${session_name}'"
        exit 1
    fi

    # Remove any stale settings.json that may have invalid permission syntax
    # (we use --dangerously-skip-permissions instead)
    limactl shell --workdir / "${vm_name}" -- bash -c 'rm -f $HOME/.claude/settings.json'

    # Send claude command to the session (skip permissions since VM is sandboxed)
    limactl shell --workdir / "${vm_name}" -- tmux send-keys -t "${session_name}" "claude --dangerously-skip-permissions" Enter

    # Attach to the session
    info "Attaching to ${session_name}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session_name}"
}

# Command: stop
cmd_stop() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}"

    stop_vm "${vm_name}"
}

# Command: shell
cmd_shell() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    start_vm "${vm_name}"
    limactl shell --workdir /workspace "${vm_name}"
}

# Command: attach
cmd_attach() {
    check_lima
    local session="${1:-}"
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    start_vm "${vm_name}"

    if [[ -z "${session}" ]]; then
        # Attach to most recent session
        local latest=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)
        if [[ -z "${latest}" ]]; then
            error "No Claude sessions found. Run 'csb start' to create one."
            exit 1
        fi
        session="${latest}"
    elif [[ "${session}" =~ ^[0-9]+$ ]]; then
        session="claude-${session}"
    fi

    info "Attaching to ${session}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session}"
}

# Command: list
cmd_list() {
    check_lima
    local vm_name=$(get_vm_name)

    echo "VM: ${vm_name}"
    echo "Status: $(vm_status "${vm_name}")"
    echo ""

    if vm_exists "${vm_name}" && [[ "$(vm_status "${vm_name}")" == "Running" ]]; then
        echo "Sessions:"
        list_sessions "${vm_name}"
    fi
}

# Command: status
cmd_status() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        echo "No VM configured for this directory"
        exit 0
    fi

    local status=$(vm_status "${vm_name}")
    echo "VM: ${vm_name}"
    echo "Status: ${status}"

    if [[ -f "${CSB_FILE}" ]]; then
        echo ""
        echo "Config:"
        tail -n +2 "${CSB_FILE}"
    fi
}

# Command: config
cmd_config() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}" "No VM found for this directory. Run 'csb start' first."

    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "${key}" ]]; then
        echo "Usage: csb config <key> <value>"
        echo ""
        echo "Keys:"
        echo "  cpus     Number of CPUs (e.g., 4)"
        echo "  memory   Memory size (e.g., 4GiB)"
        echo "  disk     Disk size (e.g., 50GiB)"
        echo ""
        echo "Note: Changes require VM restart (csb stop && csb start)"
        exit 0
    fi

    warn "VM configuration changes require editing Lima config directly."
    echo "Run: limactl edit ${vm_name}"
}

# Command: destroy
cmd_destroy() {
    check_lima
    local vm_name=$(get_vm_name)

    require_vm "${vm_name}"

    warn "This will permanently delete the VM: ${vm_name}"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "${vm_name}"
        rm -f "${CSB_FILE}"
        success "VM destroyed"
    else
        info "Cancelled"
    fi
}

# Command: help
cmd_help() {
    cat << EOF
csb - Claude SandBox v${VERSION}

Usage: csb [--verbose] <command> [options]

Commands:
  start          Create new Claude session and attach (creates VM on first run)
  stop           Shut down the VM
  shell          Open bash shell inside VM
  attach [n]     Attach to session n (or most recent if n not specified)
  list           Show VM status and all sessions
  status         Show VM state
  config         Adjust VM resources (requires restart)
  destroy        Permanently delete the VM
  help           Show this help message

Options:
  --verbose, -v  Show detailed output from Lima commands

Examples:
  csb start           # Start Claude in sandbox (creates VM if needed)
  csb --verbose start # Start with detailed Lima output
  csb attach 1        # Attach to session claude-1
  csb shell           # Open shell in VM
  csb stop            # Stop the VM

Environment:
  ANTHROPIC_API_KEY   API key for Claude (passed to VM)
  CSB_VERBOSE=true    Enable verbose output

Notes:
  Claude runs with --dangerously-skip-permissions since the VM itself
  provides sandboxing (network allowlist, isolated filesystem).

EOF
}

# Main
main() {
    # Parse global flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd="${1:-help}"
    shift || true

    case "${cmd}" in
        start)   cmd_start "$@" ;;
        stop)    cmd_stop "$@" ;;
        shell)   cmd_shell "$@" ;;
        attach)  cmd_attach "$@" ;;
        list)    cmd_list "$@" ;;
        status)  cmd_status "$@" ;;
        config)  cmd_config "$@" ;;
        destroy) cmd_destroy "$@" ;;
        help|-h|--help) cmd_help ;;
        version|--version) echo "csb v${VERSION}" ;;
        *)
            error "Unknown command: ${cmd}"
            echo "Run 'csb help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
