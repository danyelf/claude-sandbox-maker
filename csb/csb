#!/bin/bash
# csb - Claude SandBox
# Lima-powered sandboxed environment for Claude Code development

set -e

VERSION="0.1.0"
CSB_DIR="${HOME}/.csb"
CSB_FILE=".csb"
TEMPLATE_FILE="${CSB_DIR}/template.yaml"
NETWORK_RULES="${CSB_DIR}/network-rules.sh"
VERBOSE="${CSB_VERBOSE:-false}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Print colored message
info() { echo -e "${BLUE}[csb]${NC} $1"; }
success() { echo -e "${GREEN}[csb]${NC} $1"; }
warn() { echo -e "${YELLOW}[csb]${NC} $1"; }
error() { echo -e "${RED}[csb]${NC} $1" >&2; }
dim() { echo -e "${GRAY}     $1${NC}"; }

# Spinner for long-running operations
spinner_pid=""
start_spinner() {
    local msg="$1"
    if [[ "${VERBOSE}" == "true" ]]; then
        info "$msg"
        return
    fi

    (
        local chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
        local i=0
        while true; do
            printf "\r${BLUE}[csb]${NC} %s %s" "$msg" "${chars:$i:1}"
            i=$(( (i + 1) % 10 ))
            sleep 0.1
        done
    ) &
    spinner_pid=$!
    disown $spinner_pid 2>/dev/null
}

stop_spinner() {
    local success="${1:-true}"
    local msg="${2:-}"

    if [[ -n "$spinner_pid" ]]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null || true
        spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi

    if [[ -n "$msg" ]]; then
        if [[ "$success" == "true" ]]; then
            success "$msg"
        else
            error "$msg"
        fi
    fi
}

# Progress spinner with timing - for long operations with stage updates
# Uses a state file to communicate between main loop and spinner
progress_spinner_statefile=""
progress_spinner_pid=""

start_progress_spinner() {
    local initial_stage="$1"
    local start_time=$(date +%s)

    progress_spinner_statefile=$(mktemp)
    echo "${initial_stage}" > "${progress_spinner_statefile}"
    echo "${start_time}" >> "${progress_spinner_statefile}"

    (
        local chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
        local i=0
        local stime="${start_time}"
        while [[ -f "${progress_spinner_statefile}" ]]; do
            local stage=$(head -1 "${progress_spinner_statefile}" 2>/dev/null || echo "Starting")
            local now=$(date +%s)
            local elapsed=$((now - stime))
            local elapsed_str
            if [[ $elapsed -lt 60 ]]; then
                elapsed_str="${elapsed}s"
            else
                elapsed_str="$((elapsed / 60))m $((elapsed % 60))s"
            fi
            printf "\r${BLUE}[csb]${NC} %s %s ${GRAY}[%s]${NC}" "${stage}" "${chars:$i:1}" "${elapsed_str}"
            i=$(( (i + 1) % 10 ))
            sleep 0.1
        done
    ) &
    progress_spinner_pid=$!
    disown $progress_spinner_pid 2>/dev/null
}

update_progress_spinner() {
    local new_stage="$1"
    if [[ -n "${progress_spinner_statefile}" && -f "${progress_spinner_statefile}" ]]; then
        local stime=$(tail -1 "${progress_spinner_statefile}")
        echo "${new_stage}" > "${progress_spinner_statefile}"
        echo "${stime}" >> "${progress_spinner_statefile}"
    fi
}

stop_progress_spinner() {
    if [[ -n "${progress_spinner_statefile}" ]]; then
        rm -f "${progress_spinner_statefile}"
        progress_spinner_statefile=""
    fi
    if [[ -n "${progress_spinner_pid}" ]]; then
        kill $progress_spinner_pid 2>/dev/null
        wait $progress_spinner_pid 2>/dev/null || true
        progress_spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi
}

# Run command with spinner (suppresses output unless verbose or error)
run_with_spinner() {
    local msg="$1"
    shift
    local success_msg="${1:-}"
    shift

    start_spinner "$msg"

    local output
    local exit_code=0
    if [[ "${VERBOSE}" == "true" ]]; then
        stop_spinner true ""
        info "$msg"
        "$@" || exit_code=$?
    else
        output=$("$@" 2>&1) || exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        stop_spinner true "${success_msg:-$msg... done}"
        return 0
    else
        stop_spinner false "$msg... failed"
        if [[ -n "$output" ]]; then
            echo "$output" >&2
        fi
        # Exit directly to ensure error is visible before set -e kills us
        exit $exit_code
    fi
}

# Cleanup function for all spinners
cleanup_spinners() {
    stop_spinner false "" 2>/dev/null
    stop_progress_spinner 2>/dev/null
}

# Trap EXIT, INT (Ctrl+C), and TERM signals
trap cleanup_spinners EXIT INT TERM

# Escape string for use in sed replacement (handles |, &, \, newlines)
escape_sed_replacement() {
    printf '%s' "$1" | sed -e 's/[&\|]/\\&/g' -e 's/$/\\/' | tr -d '\n' | sed 's/\\$//'
}

# Format seconds as human-readable duration
format_duration() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s"
    else
        local mins=$((seconds / 60))
        local secs=$((seconds % 60))
        echo "${mins}m ${secs}s"
    fi
}

# Check if Lima is installed
check_lima() {
    if ! command -v limactl &> /dev/null; then
        error "Lima is not installed. Please install it first:"
        echo "  brew install lima"
        exit 1
    fi
}

# Generate VM name from directory path
generate_vm_name() {
    local hash=$(echo -n "$(pwd)" | shasum | cut -c1-6)
    echo "csb-${hash}"
}

# Get or create VM name for current directory
get_vm_name() {
    if [[ -f "${CSB_FILE}" ]]; then
        head -n 1 "${CSB_FILE}"
    else
        generate_vm_name
    fi
}

# Save VM config
save_config() {
    local vm_name="$1"
    echo "${vm_name}" > "${CSB_FILE}"
    echo "# csb config - do not edit manually" >> "${CSB_FILE}"
    echo "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${CSB_FILE}"
    echo "workspace=$(pwd)" >> "${CSB_FILE}"
}

# Check if VM exists
vm_exists() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    limactl list --json 2>/dev/null | jq -e "select(.name == \"${vm_name}\")" > /dev/null 2>&1
}

# Get VM status
vm_status() {
    local vm_name="$1"
    # Lima outputs JSON Lines (one object per line), not an array
    local status=$(limactl list --json 2>/dev/null | jq -r "select(.name == \"${vm_name}\") | .status" 2>/dev/null)
    echo "${status:-NotFound}"
}

# Create VM from template
create_vm() {
    local vm_name="$1"
    local workspace="$(pwd)"
    local create_start_time=$(date +%s)

    info "Creating VM: ${vm_name}"
    dim "This may take a few minutes on first run..."
    echo ""

    # Ensure CSB directory exists
    mkdir -p "${CSB_DIR}"

    # Check if template exists, if not copy it
    if [[ ! -f "${TEMPLATE_FILE}" ]]; then
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ -f "${script_dir}/template.yaml" ]]; then
            cp "${script_dir}/template.yaml" "${TEMPLATE_FILE}"
            cp "${script_dir}/network-rules.sh" "${NETWORK_RULES}"
        else
            error "Template not found. Please reinstall csb."
            exit 1
        fi
    fi

    # Create temporary template with workspace substituted
    local tmp_template=$(mktemp)
    local escaped_workspace=$(escape_sed_replacement "${workspace}")
    sed "s|{{WORKSPACE_PATH}}|${escaped_workspace}|g" "${TEMPLATE_FILE}" > "${tmp_template}"

    # Substitute API key if set
    if [[ -n "${ANTHROPIC_API_KEY}" ]]; then
        local escaped_key=$(escape_sed_replacement "${ANTHROPIC_API_KEY}")
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}|${escaped_key}|g" "${tmp_template}"
    else
        sed -i.bak "s|{{ANTHROPIC_API_KEY}}||g" "${tmp_template}"
    fi
    rm -f "${tmp_template}.bak"

    # Create the VM with progress feedback (--tty=false skips interactive prompts)
    run_with_spinner "Downloading VM image" "VM image ready" \
        limactl create --tty=false --name="${vm_name}" "${tmp_template}"
    rm -f "${tmp_template}"

    # Save config
    save_config "${vm_name}"

    local create_elapsed=$(($(date +%s) - create_start_time))
    local create_duration=$(format_duration $create_elapsed)
    echo ""
    success "VM created: ${vm_name} ${GRAY}(${create_duration})${NC}"
}

# Start VM with progress display
# Polls cloud-init log for CSB_PROGRESS markers
start_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" == "Running" ]]; then
        info "VM already running"
        return 0
    fi

    info "Starting VM: ${vm_name}"
    dim "First start provisions the VM (this takes a few minutes)..."
    echo ""

    if [[ "${VERBOSE}" == "true" ]]; then
        # Verbose mode: show all output
        limactl start --progress "${vm_name}"
    else
        # Normal mode: show progress with spinner and timing
        local tmpfile=$(mktemp)
        local exit_code=0
        local last_stage=""
        local current_stage="Booting VM"

        # Timing tracking
        local start_time=$(date +%s)
        local stage_start_time=$start_time

        # Start progress spinner (runs at 0.1s for smooth animation)
        start_progress_spinner "${current_stage}"

        # Start limactl in background (without --progress to avoid noise)
        limactl start "${vm_name}" > "${tmpfile}" 2>&1 &
        local lima_pid=$!
        disown $lima_pid 2>/dev/null

        # Monitor progress by polling cloud-init log via SSH (1s interval)
        while kill -0 $lima_pid 2>/dev/null; do
            # Try to get latest progress from VM's cloud-init log
            local new_stage=""
            if limactl shell --workdir / "${vm_name}" -- sudo test -f /var/log/cloud-init-output.log 2>/dev/null; then
                new_stage=$(limactl shell --workdir / "${vm_name}" -- sudo grep 'CSB_PROGRESS:' /var/log/cloud-init-output.log 2>/dev/null | tail -1 | sed 's/.*CSB_PROGRESS://' || true)
            fi

            if [[ -n "${new_stage}" && "${new_stage}" != "${last_stage}" ]]; then
                # Calculate elapsed time for completed stage
                local now=$(date +%s)
                local stage_elapsed=$((now - stage_start_time))
                local stage_duration=$(format_duration $stage_elapsed)

                # Show completed stage with timing
                stop_progress_spinner
                success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"

                # Start timing new stage
                current_stage="${new_stage}"
                last_stage="${new_stage}"
                stage_start_time=$now

                # Restart spinner with new stage
                start_progress_spinner "${current_stage}"
            fi

            sleep 1
        done

        # Stop spinner and get exit code
        stop_progress_spinner
        wait $lima_pid || exit_code=$?

        # Calculate final timing
        local end_time=$(date +%s)
        local final_stage_elapsed=$((end_time - stage_start_time))
        local total_elapsed=$((end_time - start_time))
        local stage_duration=$(format_duration $final_stage_elapsed)
        local total_duration=$(format_duration $total_elapsed)

        if [[ $exit_code -eq 0 ]]; then
            success "✓ ${current_stage} ${GRAY}(${stage_duration})${NC}"
            echo ""
            success "VM started ${GRAY}(total: ${total_duration})${NC}"
        else
            error "Failed to start VM after ${total_duration}"
            echo ""
            # Show output for debugging
            cat "${tmpfile}" >&2
            rm -f "${tmpfile}"
            exit $exit_code
        fi

        rm -f "${tmpfile}"
    fi
}

# Stop VM
stop_vm() {
    local vm_name="$1"

    local status=$(vm_status "${vm_name}")
    if [[ "${status}" != "Running" ]]; then
        info "VM is not running"
        return 0
    fi

    run_with_spinner "Stopping VM" "VM stopped" \
        limactl stop "${vm_name}"
}

# Get next tmux session number
get_next_session() {
    local vm_name="$1"
    local sessions=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)

    if [[ -z "${sessions}" ]]; then
        echo "claude-1"
    else
        local num=$(echo "${sessions}" | sed 's/claude-//')
        echo "claude-$((num + 1))"
    fi
}

# List tmux sessions
list_sessions() {
    local vm_name="$1"
    limactl shell --workdir / "${vm_name}" -- tmux list-sessions 2>/dev/null || echo "No sessions"
}

# Command: start
cmd_start() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        create_vm "${vm_name}"
    fi

    start_vm "${vm_name}"

    # Create new tmux session with Claude
    local session_name=$(get_next_session "${vm_name}")
    info "Creating session: ${session_name}"

    limactl shell --workdir / "${vm_name}" -- tmux new-session -d -s "${session_name}" -c /workspace "claude" 2>/dev/null || true

    # Attach to the session
    info "Attaching to ${session_name}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session_name}"
}

# Command: stop
cmd_stop() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory"
        exit 1
    fi

    stop_vm "${vm_name}"
}

# Command: shell
cmd_shell() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    start_vm "${vm_name}"
    limactl shell "${vm_name}" --workdir /workspace
}

# Command: attach
cmd_attach() {
    check_lima
    local session="${1:-}"
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    start_vm "${vm_name}"

    if [[ -z "${session}" ]]; then
        # Attach to most recent session
        local latest=$(limactl shell --workdir / "${vm_name}" -- tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^claude-[0-9]+$' | sort -t'-' -k2 -n | tail -1)
        if [[ -z "${latest}" ]]; then
            error "No Claude sessions found. Run 'csb start' to create one."
            exit 1
        fi
        session="${latest}"
    elif [[ "${session}" =~ ^[0-9]+$ ]]; then
        session="claude-${session}"
    fi

    info "Attaching to ${session}..."
    limactl shell --workdir /workspace "${vm_name}" -- tmux attach-session -t "${session}"
}

# Command: list
cmd_list() {
    check_lima
    local vm_name=$(get_vm_name)

    echo "VM: ${vm_name}"
    echo "Status: $(vm_status "${vm_name}")"
    echo ""

    if vm_exists "${vm_name}" && [[ "$(vm_status "${vm_name}")" == "Running" ]]; then
        echo "Sessions:"
        list_sessions "${vm_name}"
    fi
}

# Command: status
cmd_status() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        echo "No VM configured for this directory"
        exit 0
    fi

    local status=$(vm_status "${vm_name}")
    echo "VM: ${vm_name}"
    echo "Status: ${status}"

    if [[ -f "${CSB_FILE}" ]]; then
        echo ""
        echo "Config:"
        cat "${CSB_FILE}" | tail -n +2
    fi
}

# Command: config
cmd_config() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory. Run 'csb start' first."
        exit 1
    fi

    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "${key}" ]]; then
        echo "Usage: csb config <key> <value>"
        echo ""
        echo "Keys:"
        echo "  cpus     Number of CPUs (e.g., 4)"
        echo "  memory   Memory size (e.g., 4GiB)"
        echo "  disk     Disk size (e.g., 50GiB)"
        echo ""
        echo "Note: Changes require VM restart (csb stop && csb start)"
        exit 0
    fi

    warn "VM configuration changes require editing Lima config directly."
    echo "Run: limactl edit ${vm_name}"
}

# Command: destroy
cmd_destroy() {
    check_lima
    local vm_name=$(get_vm_name)

    if ! vm_exists "${vm_name}"; then
        error "No VM found for this directory"
        exit 1
    fi

    warn "This will permanently delete the VM: ${vm_name}"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "${vm_name}"
        rm -f "${CSB_FILE}"
        success "VM destroyed"
    else
        info "Cancelled"
    fi
}

# Command: help
cmd_help() {
    cat << EOF
csb - Claude SandBox v${VERSION}

Usage: csb [--verbose] <command> [options]

Commands:
  start          Create new Claude session and attach (creates VM on first run)
  stop           Shut down the VM
  shell          Open bash shell inside VM
  attach [n]     Attach to session n (or most recent if n not specified)
  list           Show VM status and all sessions
  status         Show VM state
  config         Adjust VM resources (requires restart)
  destroy        Permanently delete the VM
  help           Show this help message

Options:
  --verbose, -v  Show detailed output from Lima commands

Examples:
  csb start           # Start Claude in sandbox (creates VM if needed)
  csb --verbose start # Start with detailed Lima output
  csb attach 1        # Attach to session claude-1
  csb shell           # Open shell in VM
  csb stop            # Stop the VM

Environment:
  ANTHROPIC_API_KEY   API key for Claude (passed to VM)
  CSB_VERBOSE=true    Enable verbose output

EOF
}

# Main
main() {
    # Parse global flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd="${1:-help}"
    shift || true

    case "${cmd}" in
        start)   cmd_start "$@" ;;
        stop)    cmd_stop "$@" ;;
        shell)   cmd_shell "$@" ;;
        attach)  cmd_attach "$@" ;;
        list)    cmd_list "$@" ;;
        status)  cmd_status "$@" ;;
        config)  cmd_config "$@" ;;
        destroy) cmd_destroy "$@" ;;
        help|-h|--help) cmd_help ;;
        version|--version) echo "csb v${VERSION}" ;;
        *)
            error "Unknown command: ${cmd}"
            echo "Run 'csb help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
